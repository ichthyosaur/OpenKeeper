<!doctype html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' fill='%236b0f0f'/%3E%3Ccircle cx='16' cy='16' r='6' fill='%232a1a0e'/%3E%3C/svg%3E" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Cinzel:wght@400;600;700&family=EB+Garamond:wght@400;500;600&family=Caveat:wght@400;600&family=UnifrakturMaguntia&display=swap" rel="stylesheet" />
    <title>OpenKeeper</title>
    <style>
      :root {
        --parchment: #f4e4c1;
        --parchment-deep: #e8d5a3;
        --ink: #2a1a0e;
        --text: #2a1a0e;
        --title-ink: #1a0f08;
        --blood: #6b0f0f;
        --border: #8b7355;
        --shadow-ink: #0a0500;
        --panel: #f6e8c6;
        --panel-2: #ead8a8;
        --accent: #8b0000;
        --accent-2: #5c4033;
        --muted: #6b4a3d;
        --glow: rgba(107, 15, 15, 0.12);
        --stroke: rgba(92, 64, 51, 0.45);
        --shadow: 0 18px 36px rgba(10, 5, 0, 0.25);
        --paper-texture: url("https://www.transparenttextures.com/patterns/paper-fibers.png");
        --paper-texture-light: url("https://www.transparenttextures.com/patterns/natural-paper.png");
      }
      :root[data-theme="archive"] {
        --parchment: #f4e4c1;
        --panel: #f6e8c6;
        --panel-2: #ead8a8;
        --accent: #8b0000;
        --muted: #6b4a3d;
      }
      :root[data-theme="nautical"] {
        --parchment: #efe0b8;
        --panel: #f4e4c1;
        --panel-2: #e6cf9c;
        --accent: #7a0000;
        --muted: #6b4a3d;
      }
      :root[data-theme="newsprint"] {
        --parchment: #f4e4c1;
        --panel: #f6e8c6;
        --panel-2: #ead8a8;
        --accent: #8b0000;
        --muted: #6b4a3d;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "EB Garamond", Georgia, "Palatino Linotype", serif;
        font-size: 16px;
        color: var(--ink);
        text-shadow: 0 0 1px rgba(42, 26, 14, 0.3);
        min-height: 100vh;
        background-image:
          url("https://images.pexels.com/photos/235985/pexels-photo-235985.jpeg?auto=compress&cs=tinysrgb&w=2000");
        background-size: cover;
        background-position: center;
        background-attachment: fixed;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image:
          radial-gradient(circle at 18% 24%, rgba(196, 168, 122, 0.35) 0, transparent 55%),
          radial-gradient(circle at 72% 28%, rgba(84, 52, 30, 0.16) 0, transparent 58%),
          radial-gradient(circle at 60% 82%, rgba(84, 52, 30, 0.18) 0, transparent 62%),
          linear-gradient(135deg, rgba(0, 0, 0, 0.02), transparent 45%),
          repeating-linear-gradient(45deg, rgba(196, 168, 122, 0.16) 0 1px, transparent 1px 18px),
          var(--paper-texture);
        background-size: auto, auto, auto, auto, auto, 280px 280px;
        opacity: 0.65;
        pointer-events: none;
        mix-blend-mode: multiply;
      }
      body::after {
        content: "";
        position: fixed;
        inset: 0;
        background-image:
          radial-gradient(ellipse at center, transparent 30%, rgba(10, 5, 0, 0.55) 100%),
          radial-gradient(420px 260px at 12% 18%, rgba(10, 5, 0, 0.35), transparent 70%),
          radial-gradient(520px 340px at 86% 86%, rgba(10, 5, 0, 0.32), transparent 70%);
        opacity: 0.95;
        pointer-events: none;
      }
      .app::after {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at center, transparent 60%, rgba(10, 5, 0, 0.45) 100%);
        pointer-events: none;
        z-index: 0;
      }
      .parchment {
        background:
          radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.6), transparent 45%),
          radial-gradient(circle at 80% 30%, rgba(255, 255, 255, 0.4), transparent 50%),
          radial-gradient(circle at 50% 80%, rgba(212, 184, 130, 0.35), transparent 55%),
          linear-gradient(180deg, rgba(0, 0, 0, 0.04), rgba(0, 0, 0, 0));
        box-shadow:
          inset 0 0 26px rgba(93, 74, 48, 0.18),
          inset 0 0 8px rgba(93, 74, 48, 0.12);
        -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220' viewBox='0 0 220 220'%3E%3Cfilter id='f'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' seed='3'/%3E%3CfeDisplacementMap in='SourceGraphic' scale='6'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' fill='white' filter='url(%23f)'/%3E%3C/svg%3E");
        mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220' viewBox='0 0 220 220'%3E%3Cfilter id='f'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' seed='3'/%3E%3CfeDisplacementMap in='SourceGraphic' scale='6'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' fill='white' filter='url(%23f)'/%3E%3C/svg%3E");
      }
      :root[data-theme="nautical"] body::before {
        background-image:
          radial-gradient(rgba(45, 212, 191, 0.12) 1px, transparent 1px),
          url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240' viewBox='0 0 240 240'%3E%3Cpath d='M0 30 Q60 0 120 30 T240 30' fill='none' stroke='rgba(45,212,191,0.18)' stroke-width='1'/%3E%3Cpath d='M0 90 Q60 60 120 90 T240 90' fill='none' stroke='rgba(45,212,191,0.14)' stroke-width='1'/%3E%3Cpath d='M0 150 Q60 120 120 150 T240 150' fill='none' stroke='rgba(45,212,191,0.12)' stroke-width='1'/%3E%3Cpath d='M0 210 Q60 180 120 210 T240 210' fill='none' stroke='rgba(45,212,191,0.1)' stroke-width='1'/%3E%3C/svg%3E");
        background-size: 22px 22px, 240px 240px;
        opacity: 0.2;
      }
      :root[data-theme="newsprint"] body::before {
        background-image:
          radial-gradient(rgba(199, 185, 162, 0.18) 1px, transparent 1px),
          url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240' viewBox='0 0 240 240'%3E%3Cpath d='M0 20 H240' stroke='rgba(199,185,162,0.15)' stroke-width='1'/%3E%3Cpath d='M0 60 H240' stroke='rgba(199,185,162,0.12)' stroke-width='1'/%3E%3Cpath d='M0 100 H240' stroke='rgba(199,185,162,0.1)' stroke-width='1'/%3E%3Cpath d='M0 140 H240' stroke='rgba(199,185,162,0.08)' stroke-width='1'/%3E%3Cpath d='M0 180 H240' stroke='rgba(199,185,162,0.06)' stroke-width='1'/%3E%3Cpath d='M0 220 H240' stroke='rgba(199,185,162,0.05)' stroke-width='1'/%3E%3C/svg%3E");
        background-size: 26px 26px, 240px 240px;
        opacity: 0.18;
      }
      .app { min-height: 100vh; padding: 24px; display: flex; flex-direction: column; gap: 20px; position: relative; z-index: 1; animation: fadeInUp 0.8s ease both; }
      .paper-fog {
        position: fixed;
        inset: -20%;
        background:
          radial-gradient(60% 40% at 20% 30%, rgba(255, 255, 255, 0.08), transparent 60%),
          radial-gradient(50% 50% at 80% 70%, rgba(255, 255, 255, 0.06), transparent 60%);
        animation: fogDrift 24s ease-in-out infinite alternate;
        pointer-events: none;
        mix-blend-mode: soft-light;
        z-index: 0;
      }
      .topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background:
          linear-gradient(120deg, rgba(107, 15, 15, 0.18), transparent 55%),
          linear-gradient(135deg, rgba(244, 228, 193, 0.96), rgba(232, 213, 163, 0.96)),
          var(--paper-texture);
        padding: 18px 22px;
        border-radius: 18px;
        box-shadow:
          inset 0 0 18px rgba(92, 64, 51, 0.2),
          inset 0 0 45px rgba(10, 5, 0, 0.25),
          var(--shadow);
        position: relative;
        overflow: hidden;
      }
      .title { font-size: 28px; font-weight: 700; font-family: "Cinzel Decorative", serif; letter-spacing: 0.2em; color: var(--title-ink); text-shadow: 0 1px 0 rgba(244,228,193,0.4), 0 -1px 1px rgba(0,0,0,0.2); animation: candleFlicker 5s ease-in-out infinite; }
      .title::after {
        content: "";
        display: inline-block;
        width: 18px;
        height: 18px;
        margin-left: 8px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpath d='M24 2 L28 18 L46 22 L30 26 L34 44 L24 32 L14 44 L18 26 L2 22 L20 18 Z' fill='%236b0f0f'/%3E%3C/svg%3E");
        background-size: contain;
        background-repeat: no-repeat;
        opacity: 0.7;
        animation: sigilSpin 6s linear infinite;
        vertical-align: middle;
      }
      .subtitle { font-size: 13px; color: var(--muted); font-family: "Cinzel", serif; letter-spacing: 0.16em; text-transform: uppercase; line-height: 1.4; }
      .status { padding: 8px 14px; border-radius: 999px; font-size: 12px; letter-spacing: 0.1em; }
      .status.on { background: #cfe9d6; color: #2a1a0e; }
      .status.off { background: #f2c9c5; color: #2a1a0e; }
      .status.warn { background: rgba(107, 15, 15, 0.4); color: #f6e7cf; }
      .notice { margin-top: 8px; font-size: 12px; color: rgba(42, 26, 14, 0.55); line-height: 1.6; }
      .notice.warning {
        color: var(--ink);
        background: rgba(244, 228, 193, 0.96);
        padding: 6px 10px;
        border-radius: 8px;
        outline: 1px solid rgba(92, 64, 51, 0.35);
        display: none;
        align-items: center;
        gap: 6px;
      }
      .notice.warning.active { display: inline-flex; }
      .notice.warning.active::before {
        content: "WARNING";
        font-size: 9px;
        letter-spacing: 0.2em;
        color: rgba(92, 64, 51, 0.7);
      }
      .links { display: flex; gap: 10px; font-size: 12px; }
      .links a { color: var(--accent); text-decoration: none; }
      .setup { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; animation: fadeInUp 0.5s ease both; }
      .card {
        background: linear-gradient(160deg, rgba(246, 232, 198, 0.98), rgba(234, 216, 168, 0.95)), var(--paper-texture-light);
        padding: 18px;
        border-radius: 18px;
        outline: 1px solid rgba(92, 64, 51, 0.4);
        box-shadow: 0 12px 24px rgba(10, 5, 0, 0.22), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        position: relative;
        transform: translateY(-2px);
        transition: transform 0.35s ease, box-shadow 0.35s ease;
        z-index: 1;
      }
      .card:hover { transform: translateY(-6px); box-shadow: 0 16px 30px rgba(10, 5, 0, 0.28); }
      .card::before {
        content: "";
        position: absolute;
        inset: 1px;
        border-radius: 17px;
        border: 1px solid rgba(92, 64, 51, 0.35);
        pointer-events: none;
      }
      .card-title { font-weight: 700; margin-bottom: 10px; font-family: "Cinzel Decorative", serif; letter-spacing: 0.06em; color: var(--title-ink); line-height: 1.3; }
      .grid { display: grid; gap: 10px; }
      label { display: flex; flex-direction: column; gap: 6px; font-size: 13px; color: rgba(42, 26, 14, 0.65); }
      input, select {
        padding: 9px 12px;
        border-radius: 8px;
        border: none;
        border-bottom: 1px solid #8b7355;
        background: transparent;
        color: var(--ink);
        box-shadow: none;
      }
      input::placeholder, textarea::placeholder { color: rgba(42, 26, 14, 0.45); font-style: italic; }
      input:focus, select:focus, textarea:focus {
        outline: none;
        border-bottom-color: #6b0f0f;
        box-shadow: 0 0 0 1px rgba(107, 15, 15, 0.12);
      }
      button {
        background:
          radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2), transparent 45%),
          radial-gradient(circle at 70% 70%, rgba(0,0,0,0.2), transparent 55%),
          radial-gradient(circle at center, #9b1b1b, #4a0808);
        color: #f6e7cf;
        border: 1px solid rgba(10, 5, 0, 0.7);
        padding: 10px 18px;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 700;
        box-shadow:
          0 10px 22px rgba(10, 5, 0, 0.45),
          inset 0 2px 6px rgba(255,255,255,0.15),
          inset 0 -3px 8px rgba(0,0,0,0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
      }
      button:focus { outline: none; }
      button:hover { transform: translateY(-1px) scale(1.02); box-shadow: 0 14px 28px rgba(10, 5, 0, 0.5); filter: brightness(1.05); }
      button:active { transform: scale(0.95); box-shadow: 0 6px 14px rgba(10, 5, 0, 0.35), inset 0 2px 10px rgba(0,0,0,0.45); }
      .actions { margin-top: 12px; display: flex; gap: 8px; }
      .save-list { margin-top: 12px; display: flex; flex-direction: column; gap: 10px; }
      .save-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 12px;
        border-radius: 12px;
        background: rgba(244, 228, 193, 0.98);
        outline: 1px solid rgba(92, 64, 51, 0.35);
        font-size: 12px;
      }
      .lan-tip { margin-top: 12px; padding: 12px; border-radius: 12px; outline: 1px dashed rgba(92, 64, 51, 0.35); background: rgba(244, 228, 193, 0.98); display: grid; gap: 8px; }
      .lan-title { font-weight: 600; font-size: 13px; }
      .lan-row { display: flex; justify-content: space-between; gap: 10px; font-size: 12px; word-break: break-all; }
      .room { display: grid; grid-template-columns: minmax(0, 2.2fr) minmax(220px, 0.85fr); gap: 16px; animation: fadeInUp 0.5s ease both; }
      .hidden { display: none !important; }
      .divider { height: 1px; background: rgba(92, 64, 51, 0.35); margin: 12px 0; }
      .panel {
        background:
          linear-gradient(170deg, rgba(246, 232, 198, 0.96), rgba(234, 216, 168, 0.96)),
          var(--paper-texture-light);
        border-radius: 18px;
        padding: 16px;
        box-shadow:
          inset 0 0 18px rgba(92, 64, 51, 0.18),
          inset 0 0 45px rgba(10, 5, 0, 0.18),
          0 12px 24px rgba(10, 5, 0, 0.22);
        outline: 1px solid rgba(92, 64, 51, 0.45);
        position: relative;
        overflow: visible;
        transform: translateY(-2px);
        transition: transform 0.35s ease, box-shadow 0.35s ease;
      }
      .panel::before, .panel::after {
        content: "";
        position: absolute;
        width: 14px;
        height: 14px;
        border: 1px solid rgba(92, 64, 51, 0.5);
        pointer-events: none;
      }
      .panel::before { top: 8px; left: 8px; border-right: none; border-bottom: none; }
      .panel::after { bottom: 8px; right: 8px; border-left: none; border-top: none; }
      .panel:hover { transform: translateY(-6px); box-shadow: 0 16px 30px rgba(10, 5, 0, 0.28), inset 0 0 18px rgba(92, 64, 51, 0.2); }
      .panel.history { transform: translateY(-2px); }
      .panel.history:hover { transform: translateY(-6px); }
      .panel:has(.info-item:hover) { z-index: 30; }
      .panel-title { font-weight: 700; margin-bottom: 10px; position: relative; padding-bottom: 8px; letter-spacing: 0.22em; text-transform: uppercase; font-size: 12px; color: var(--title-ink); font-family: "Cinzel", serif; line-height: 1.3; }
      .panel-title::before { content: "§ "; color: var(--blood); }
      .panel-title::after {
        content: "";
        display: block;
        height: 8px;
        margin-top: 6px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='8' viewBox='0 0 220 8'%3E%3Cpath d='M0 4 Q20 0 40 4 T80 4 T120 4 T160 4 T200 4 T220 4' fill='none' stroke='%238b7355' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
        opacity: 0.8;
      }
      .panel.small { padding: 12px; }
      .roll { display: flex; flex-direction: column; gap: 6px; font-size: 13px; }
      .roll strong { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; }
      .badge { display: inline-flex; align-items: center; padding: 2px 8px; border-radius: 999px; font-size: 11px; font-weight: 700; }
      .badge.success, .badge.fail, .badge.normal {
        background: rgba(246, 232, 198, 0.92);
        color: var(--ink);
        outline: 1px solid rgba(92, 64, 51, 0.45);
        box-shadow: inset 0 0 10px rgba(92, 64, 51, 0.18);
      }
      .badge.fail { background: rgba(107, 15, 15, 0.15); }
      .modal { position: fixed; inset: 0; background: rgba(10, 5, 0, 0.78); display: flex; align-items: center; justify-content: center; z-index: 50; }
      .modal.hidden { display: none; }
      .modal-card {
        background:
          linear-gradient(160deg, rgba(244, 228, 193, 0.98), rgba(232, 213, 163, 0.98)),
          var(--paper-texture-light);
        outline: 1px solid #5c4033;
        border-radius: 16px;
        padding: 20px;
        max-width: 560px;
        width: 90%;
        position: relative;
        overflow: hidden;
        box-shadow: inset 0 0 22px rgba(92, 64, 51, 0.2), 0 18px 34px rgba(10, 5, 0, 0.35);
      }
      .modal-card::before {
        content: "";
        position: absolute;
        inset: 6px;
        border: 1px dashed rgba(152, 125, 86, 0.45);
        border-radius: 12px;
        pointer-events: none;
      }
      .modal-card::after {
        content: "ARCANE";
        position: absolute;
        right: 16px;
        top: 16px;
        font-size: 46px;
        color: rgba(92, 64, 51, 0.2);
        letter-spacing: 0.12em;
        transform: rotate(-10deg);
        font-family: "Cinzel Decorative", serif;
        pointer-events: none;
      }
      .modal-title { font-size: 18px; font-weight: 700; margin-bottom: 8px; font-family: "Cinzel Decorative", serif; color: var(--title-ink); }
      .modal-body {
        white-space: pre-wrap;
        line-height: 1.6;
        color: var(--ink);
        font-size: 14px;
        max-height: 60vh;
        overflow-y: auto;
        padding-right: 6px;
      }
      .modal-actions { margin-top: 12px; display: flex; justify-content: flex-end; }
      .history { display: flex; flex-direction: column; gap: 12px; }
      .history-wrap {
        display: grid;
        grid-template-columns: minmax(160px, 0.6fr) minmax(0, 2fr);
        gap: 12px;
        align-items: start;
      }
      .history-main { display: flex; flex-direction: column; gap: 12px; min-width: 0; }
      .summary-card { background: rgba(246, 232, 198, 0.98); outline: 1px solid rgba(92, 64, 51, 0.35); border-radius: 14px; padding: 10px 12px; position: relative; box-shadow: 0 8px 16px rgba(10, 5, 0, 0.2); transform: translateY(-2px); transition: transform 0.35s ease, box-shadow 0.35s ease; }
      .summary-card:hover { transform: translateY(-6px); box-shadow: 0 12px 22px rgba(10, 5, 0, 0.26); }
      .summary-title { font-size: 10px; letter-spacing: 0.22em; text-transform: uppercase; color: var(--blood); margin-bottom: 8px; font-family: "Cinzel", serif; }
      .summary-row { font-size: 12px; color: var(--ink); display: grid; grid-template-columns: 1fr auto; gap: 8px; line-height: 1.7; }
      .summary-row span:first-child { color: rgba(42, 26, 14, 0.6); letter-spacing: 0.06em; text-transform: uppercase; font-size: 11px; }
      .summary-row.intro { display: block; margin-top: 6px; }
      .summary-row.intro span { display: block; }
      .summary-row.intro span:last-child { margin-top: 6px; padding-left: 6px; line-height: 1.55; }
      .history-list { flex: 1; max-height: 420px; overflow: auto; display: flex; flex-direction: column; gap: 12px; }
      .history-item {
        padding: 12px;
        background: rgba(246, 232, 198, 0.95);
        border-radius: 14px;
        outline: 1px solid rgba(92, 64, 51, 0.35);
        transform: translateY(-2px);
        box-shadow: 0 10px 18px rgba(10, 5, 0, 0.2);
        position: relative;
        overflow: visible;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
      }
      .history-item:hover { transform: translateY(-6px); box-shadow: 0 14px 24px rgba(10, 5, 0, 0.28); }
      .history-item::after {
        content: "";
        position: absolute;
        inset: 0;
        background:
          radial-gradient(circle at 20% 20%, rgba(0, 0, 0, 0.12), transparent 50%),
          radial-gradient(circle at 80% 70%, rgba(0, 0, 0, 0.1), transparent 50%);
        mix-blend-mode: multiply;
        opacity: 0.22;
        pointer-events: none;
      }
      .history-item::before {
        content: attr(data-stamp);
        position: absolute;
        top: 8px;
        right: 10px;
        font-size: 9px;
        letter-spacing: 0.2em;
        color: rgba(90, 70, 50, 0.6);
        text-transform: uppercase;
        pointer-events: none;
      }
      .history-item.player { border-left: 4px solid rgba(107, 15, 15, 0.6); }
      .history-item.keeper { border-left: 4px solid rgba(107, 15, 15, 0.6); }
      .history-item.system { border-left: 4px solid rgba(92, 64, 51, 0.7); }
      .history-item.secret {
        background: rgba(234, 240, 226, 0.92);
        outline-color: rgba(92, 110, 84, 0.4);
      }
      .history-meta { font-size: 11px; color: rgba(42, 26, 14, 0.6); display: flex; align-items: center; gap: 12px; margin-bottom: 6px; letter-spacing: 0.12em; text-transform: uppercase; }
      .meta-label { font-weight: 700; color: var(--title-ink); }
      .meta-badge {
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(92, 64, 51, 0.45);
        background: rgba(244, 228, 193, 0.9);
        color: rgba(42, 26, 14, 0.7);
        letter-spacing: 0.14em;
        font-size: 10px;
      }
      .meta-badge.secret {
        background: rgba(234, 240, 226, 0.95);
        border-color: rgba(92, 110, 84, 0.45);
        color: rgba(62, 88, 58, 0.78);
        text-shadow: 0 0 1px rgba(62, 88, 58, 0.2);
      }
      .actor-stack { display: flex; flex-direction: column; line-height: 1.2; }
      .actor-name { font-size: 12px; color: var(--text); }
      .actor-prof { font-size: 10px; color: var(--muted); letter-spacing: 0.08em; text-transform: uppercase; }
      .actor-tag { font-size: 10px; padding: 2px 6px; border-radius: 999px; letter-spacing: 0.04em; text-transform: uppercase; }
      .actor-tag.player { background: rgba(107, 15, 15, 0.12); color: var(--ink); outline: 1px solid rgba(92, 64, 51, 0.45); }
      .actor-tag.keeper { background: rgba(107, 15, 15, 0.12); color: var(--ink); outline: 1px solid rgba(92, 64, 51, 0.45); }
      .actor-tag.system { background: rgba(232, 213, 163, 0.35); color: var(--ink); outline: 1px solid rgba(92, 64, 51, 0.35); }
      .history-content { font-size: 14px; letter-spacing: 0.02em; line-height: 1.82; }
      .input-row { display: flex; gap: 8px; }
      .input-row input { flex: 1; transition: border-color 0.2s ease; color: var(--ink); background: transparent; }
      .input-row input:focus {
        outline: none;
        border-bottom-color: #6b0f0f;
        box-shadow: 0 0 0 1px rgba(107, 15, 15, 0.12);
      }
      .input-row input:disabled { background: rgba(232, 218, 188, 0.4); color: #8b7d63; cursor: not-allowed; }
      .input-row button:disabled { opacity: 0.6; cursor: not-allowed; }
      .side { display: flex; flex-direction: column; gap: 16px; }
      .card-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
      .chip {
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        color: var(--ink);
        font-weight: 700;
        background: rgba(246, 232, 198, 0.96);
        outline: 1px solid rgba(92, 64, 51, 0.4);
        box-shadow: inset 0 0 10px rgba(92, 64, 51, 0.18);
      }
      .stats, .attributes { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 13px; }
      .stat-badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; background: rgba(246, 232, 198, 0.98); outline: 1px solid rgba(92, 64, 51, 0.35); font-size: 12px; color: var(--ink); }
      .stat-bar { height: 6px; border-radius: 999px; background: rgba(92, 64, 51, 0.18); overflow: hidden; }
      .stat-bar > span { display: block; height: 100%; background: linear-gradient(90deg, #8b7355, #6b0f0f); }
      .info-list { display: flex; flex-direction: column; gap: 8px; font-size: 13px; position: relative; z-index: 1; }
      .info-item { position: relative; padding: 8px 10px; border-radius: 10px; outline: 1px solid rgba(92, 64, 51, 0.35); background: rgba(244, 228, 193, 0.9); transition: transform 0.18s ease, box-shadow 0.18s ease; z-index: 1; }
      .info-text { white-space: pre-wrap; color: #5a4a38; }
      .info-item.new {
        border-color: rgba(34, 197, 94, 0.6);
        box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.3), 0 6px 18px rgba(34, 197, 94, 0.18);
        animation: findingGlow 2s ease-out forwards;
      }
      .info-item:hover { transform: translateY(-2px); box-shadow: 0 10px 24px rgba(10, 5, 0, 0.25); z-index: 3000; }
      .info-item:hover .info-reveal { opacity: 1; transform: translateY(0); pointer-events: auto; }
      .info-text { white-space: pre-wrap; }
      .info-reveal {
        position: absolute;
        left: 10px;
        right: 10px;
        top: calc(100% + 6px);
        background: rgba(246, 232, 198, 0.98);
        outline: 1px solid rgba(92, 64, 51, 0.35);
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 12px;
        color: var(--ink);
        box-shadow: 0 10px 20px rgba(10, 5, 0, 0.2);
        opacity: 0;
        transform: translateY(-4px);
        transition: opacity 0.2s ease, transform 0.2s ease;
        pointer-events: none;
        z-index: 4000;
      }
      .players { display: flex; flex-direction: column; gap: 8px; }
      .player { display: flex; align-items: center; gap: 10px; font-size: 14px; }
      .dot { width: 10px; height: 10px; border-radius: 50%; }
      .flag { font-size: 11px; padding: 2px 6px; border-radius: 999px; background: rgba(107, 15, 15, 0.18); color: var(--ink); outline: 1px solid rgba(92, 64, 51, 0.5); }
      .link-btn {
        background: transparent;
        border: 1px solid rgba(92, 64, 51, 0.4);
        color: var(--title-ink);
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
        text-align: left;
        font-family: "Cinzel", serif;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        box-shadow: none;
        border-radius: 10px;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .link-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 12px rgba(10, 5, 0, 0.2); }
      .attrs-collapsed { display: none; }
      .muted { color: rgba(42, 26, 14, 0.6); font-size: 12px; line-height: 1.5; }
      .toast-stack {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
        z-index: 60;
      }
      .toast {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        background:
          linear-gradient(160deg, rgba(246, 232, 198, 0.98), rgba(234, 216, 168, 0.96)),
          var(--paper-texture-light);
        outline: 1px solid rgba(92, 64, 51, 0.45);
        border-radius: 12px;
        box-shadow: 0 10px 20px rgba(10, 5, 0, 0.25);
        color: var(--ink);
        font-size: 13px;
        animation: toastFade 3s ease forwards;
      }
      .toast-icon { width: 20px; height: 20px; display: inline-flex; align-items: center; justify-content: center; color: var(--blood); }
      .toast-icon svg { width: 20px; height: 20px; }
      @keyframes toastFade {
        0% { opacity: 0; transform: translateY(-6px); }
        10% { opacity: 1; transform: translateY(0); }
        80% { opacity: 1; }
        100% { opacity: 0; transform: translateY(-6px); }
      }
      @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes fogDrift {
        from { transform: translate3d(-2%, -1%, 0) scale(1); opacity: 0.6; }
        to { transform: translate3d(2%, 1%, 0) scale(1.02); opacity: 0.75; }
      }
      @keyframes panelRise {
        from { transform: translateY(6px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      @keyframes gentleFlicker {
        0% { transform: rotate(-0.2deg); }
        50% { transform: rotate(0.2deg); }
        100% { transform: rotate(-0.2deg); }
      }
      @keyframes sigilSpin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      @keyframes candleFlicker {
        0% { filter: brightness(1); }
        50% { filter: brightness(1.05); }
        100% { filter: brightness(0.98); }
      }
      .summary-card, .card { animation: none; }
      @keyframes findingGlow {
        0% { border-color: rgba(34, 197, 94, 0.7); box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.45), 0 10px 24px rgba(34, 197, 94, 0.28); }
        70% { border-color: rgba(34, 197, 94, 0.4); box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.22), 0 6px 16px rgba(34, 197, 94, 0.16); }
        100% { border-color: rgba(56, 189, 248, 0.12); box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
      }
      @media (max-width: 900px) { .room { grid-template-columns: 1fr; } }
      @media (max-width: 900px) { .history-wrap { grid-template-columns: 1fr; } }
    </style>
  </head>
  <body>
    <div class="paper-fog"></div>
    <div class="app">
      <header class="topbar">
        <div>
          <div class="title">OpenKeeper</div>
          <div class="subtitle">古神正在低语……</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center;">
          <button id="backToLobby" class="hidden">返回角色选择</button>
          <div id="status" class="status off">DISCONNECTED</div>
        </div>
      </header>

      <section id="lobby" class="setup">
        <div class="card">
          <div class="card-title">选择角色</div>
          <div class="grid">
            <label>已有角色<select id="existingPlayers"></select></label>
          </div>
          <div class="actions">
            <button id="useExisting">进入游戏</button>
            <button id="deletePlayer">删除角色</button>
          </div>
          <div class="notice">选择已有角色后进入游戏界面。</div>
        </div>

        <div class="card">
          <div class="card-title">角色创建</div>
          <div class="grid">
            <label>名称<input id="name" /></label>
            <label>性别<select id="gender"><option value="男">男</option><option value="女">女</option></select></label>
            <label>颜色<input id="color" type="color" value="#2dd4bf" /></label>
            <label>职业<select id="profession">
              <option value="retired_soldier">退役士兵</option>
              <option value="police">警察</option>
              <option value="doctor">医生</option>
              <option value="professor">大学教授</option>
              <option value="private_detective">私人侦探</option>
              <option value="journalist">记者</option>
              <option value="occult_researcher">神秘学研究者</option>
              <option value="engineer">工程师</option>
              <option value="archaeologist">考古学家</option>
              <option value="nurse">护士</option>
              <option value="librarian">图书馆员</option>
              <option value="antiquarian">古董商</option>
              <option value="author">作家</option>
              <option value="painter">画家</option>
              <option value="sculptor">雕塑家</option>
              <option value="dockworker">码头工人</option>
              <option value="chemist">化学师</option>
            </select></label>
          </div>
          <div class="actions">
            <button id="create">创建角色</button>
          </div>
          <div id="notice" class="notice"></div>
        </div>

        <div class="card">
          <div class="card-title">局域网访问提示</div>
          <div class="lan-tip">
            <div class="lan-title">可分享的访问地址</div>
            <div id="lanStatus" class="muted">正在获取…</div>
            <div id="lanRows" class="hidden">
              <div class="lan-row">
                <span class="muted">内网 IP</span>
                <span id="lanIp">-</span>
              </div>
              <div class="lan-row">
                <span class="muted">玩家</span>
                <span id="lanPlayer">-</span>
              </div>
              <div class="lan-row">
                <span class="muted">Host</span>
                <span id="lanHost">-</span>
              </div>
            </div>
          </div>
          <div class="notice">手机与电脑在同一 Wi‑Fi 时可用。</div>
        </div>

      </section>

      <section id="game" class="room hidden">
        <div class="history panel">
          <div class="panel-title">历史记录</div>
          <div class="history-wrap">
            <div class="summary-card">
              <div class="summary-title">摘要</div>
              <div class="summary-row"><span>模组</span><span id="summaryModule">-</span></div>
              <div class="summary-row"><span>阶段</span><span id="summaryPhase">-</span></div>
              <div class="summary-row"><span>物品</span><span id="summaryItems">0</span></div>
              <div class="summary-row"><span>线索</span><span id="summaryClues">0</span></div>
              <div class="summary-row"><span>日期</span><span id="summaryDate">-</span></div>
              <div class="summary-row intro"><span>简介</span><span id="summaryIntro">-</span></div>
            </div>
            <div class="history-main">
              <div id="history" class="history-list"></div>
              <div class="input-row">
                <input id="actionInput" placeholder="行动输入..." />
                <button id="send">发送</button>
              </div>
              <div id="inputNotice" class="notice warning"></div>
            </div>
          </div>
        </div>

        <div class="side">
          <div class="panel">
            <div class="panel-title">角色卡</div>
            <div class="card-info">
              <div>
                <strong id="cardName">Unknown</strong>
                <div class="muted" id="cardProfession"></div>
                <div class="muted" id="cardBackground"></div>
              </div>
              <div class="chip" id="cardChip"> </div>
            </div>
            <div class="stats" id="cardStats"></div>
            <button id="toggleAttrs" class="link-btn">展开属性</button>
            <div class="attributes attrs-collapsed" id="cardAttributes"></div>
          </div>

          <div class="panel small">
            <div class="panel-title">判定面板</div>
            <div id="rollPanel" class="roll">
              <div class="muted">暂无判定</div>
            </div>
          </div>

          <div class="panel">
            <div class="panel-title">物品</div>
            <div id="itemList" class="info-list">
              <div class="muted">暂无物品</div>
            </div>
          </div>

          <div class="panel">
            <div class="panel-title">线索</div>
            <div id="clueList" class="info-list">
              <div class="muted">暂无线索</div>
            </div>
          </div>

          <div class="panel">
            <div class="panel-title">房间玩家</div>
            <div class="players" id="roomPlayers"></div>
          </div>
        </div>
      </section>
    </div>
    <div id="toastStack" class="toast-stack"></div>

    <div id="endingModal" class="modal hidden">
      <div class="modal-card">
        <div class="modal-title">模组结局</div>
        <div id="endingText" class="modal-body"></div>
        <div class="modal-actions">
          <button id="closeEnding">关闭</button>
        </div>
      </div>
    </div>

    <script>
      const el = (id) => document.getElementById(id);
      const state = {
        ws: null,
        history: [],
        stateView: { players: {} },
        sessionInfo: null,
        professions: {},
        players: [],
        machineId: "",
        onlineIds: [],
        streamingCount: 0,
        pendingEntries: [],
        activeStreamIds: new Set(),
        toastCache: new Map(),
        lastModuleName: "",
        items: [],
        clues: [],
        findingHighlights: { items: {}, clues: {} },
        attrsCollapsed: true,
        historyPinned: true,
        historyScrollReady: false,
      };

      const serverUrl = window.location.origin;
      const wsUrl = serverUrl.replace(/^http/, "ws") + "/ws";
      function makeUUID() {
        if (window.crypto && typeof window.crypto.randomUUID === "function") {
          return window.crypto.randomUUID();
        }
        const bytes = new Uint8Array(16);
        for (let i = 0; i < bytes.length; i += 1) {
          bytes[i] = Math.floor(Math.random() * 256);
        }
        bytes[6] = (bytes[6] & 0x0f) | 0x40;
        bytes[8] = (bytes[8] & 0x3f) | 0x80;
        const hex = Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");
        return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
      }

      function formatDateStamp(date = new Date()) {
        const pad = (num) => String(num).padStart(2, "0");
        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hour = pad(date.getHours());
        const minute = pad(date.getMinutes());
        return `${year}${month}${day}-${hour}${minute}`;
      }

      function defaultSaveName(moduleName) {
        const safeModule = moduleName || "module";
        return `${safeModule}-${formatDateStamp()}`;
      }
      let playerId = makeUUID();
      state.machineId = localStorage.getItem("openkeeper_machine_id");
      if (!state.machineId) {
        state.machineId = makeUUID();
        localStorage.setItem("openkeeper_machine_id", state.machineId);
      }

      function textFromI18n(content) {
        if (!content) return "";
        return content.zh || content.en || "";
      }

      function setLanInfo(info) {
        const status = el("lanStatus");
        const rows = el("lanRows");
        if (!info || !info.ip) {
          status.textContent = "无法获取局域网地址";
          rows.classList.add("hidden");
          return;
        }
        status.textContent = info.ip.startsWith("127.") ? "检测到回环地址，请检查网络或防火墙" : "已获取";
        el("lanIp").textContent = info.ip;
        el("lanPlayer").textContent = info.urls?.player || `http://${info.ip}:${info.port || 8000}/player`;
        el("lanHost").textContent = info.urls?.host || `http://${info.ip}:${info.port || 8000}/host`;
        rows.classList.remove("hidden");
      }

      fetch(`${serverUrl}/local_ip`)
        .then((res) => res.json())
        .then((data) => setLanInfo(data))
        .catch(() => setLanInfo(null));

      function renderHistory() {
        const container = el("history");
        if (!state.historyScrollReady && container) {
          container.addEventListener("scroll", () => {
            const distance = container.scrollHeight - container.scrollTop - container.clientHeight;
            state.historyPinned = distance < 24;
          });
          state.historyScrollReady = true;
        }
        const preserveFromBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
        const shouldPin = preserveFromBottom < 24 || state.historyPinned;
        container.innerHTML = "";
        state.history.forEach((entry) => {
          const item = document.createElement("div");
          item.className = `history-item ${entry.actor_type} ${entry.message_type === "secret" ? "secret" : ""}`;
          if (entry.stream_id) item.dataset.streamId = entry.stream_id;
          if (entry.actor_type === "player") {
            const pcolor = state.stateView.players?.[entry.actor_id]?.color;
            if (pcolor) item.style.borderLeftColor = pcolor;
          }
          const actor =
            entry.actor_type === "player"
              ? state.stateView.players?.[entry.actor_id]?.name || "Player"
              : entry.actor_type === "keeper"
              ? "Keeper"
              : "System";
          const profKey =
            entry.actor_type === "player"
              ? state.stateView.players?.[entry.actor_id]?.profession || ""
              : "";
          const profLabel =
            profKey && state.professions
              ? state.professions[profKey]?.label_zh ||
                state.professions[profKey]?.label ||
                profKey
              : "";
          const keeperTag =
            entry.message_type === "secret" && entry.actor_type === "keeper"
              ? "<span class=\"meta-badge secret\">SECRET</span>"
              : entry.actor_type === "keeper"
              ? "<span class=\"meta-badge\">REVEALING</span>"
              : "";
          const stamp = new Date(entry.timestamp || Date.now()).toLocaleDateString("en-US", {
            month: "short",
            day: "2-digit",
            year: "numeric",
          });
          item.setAttribute("data-stamp", stamp);
          item.innerHTML = `
            <div class="history-meta">
              ${
                entry.actor_type === "keeper"
                  ? `<span class="meta-label">KEEPER</span>${keeperTag}`
                  : entry.actor_type === "player"
                  ? `<span class="actor-tag ${entry.actor_type}">${entry.actor_type}</span><div class="actor-stack"><div class="actor-name">${actor}</div><div class="actor-prof">${profLabel || ""}</div></div>`
                  : `<span class="actor-tag ${entry.actor_type}">${entry.actor_type}</span><div class="actor-name">${actor}</div>`
              }
            </div>
            <div class="history-content">${textFromI18n(entry.content)}</div>
          `;
          container.appendChild(item);
        });
        if (shouldPin) {
          container.scrollTop = container.scrollHeight;
        } else {
          container.scrollTop = Math.max(0, container.scrollHeight - preserveFromBottom - container.clientHeight);
        }
      }

      function renderSummary() {
        const phase = state.stateView.phase || "lobby";
        const phaseMap = { lobby: "等待开始", active: "进行中", ended: "已结束" };
        const moduleName =
          phase === "active" && state.sessionInfo?.module_name
            ? state.sessionInfo.module_name
            : "尚未确定";
        const intro =
          phase === "active" ? state.sessionInfo?.module_introduction || "" : "";
        const items = state.items?.length || 0;
        const clues = state.clues?.length || 0;
        const date = new Date().toLocaleDateString("en-US", {
          month: "short",
          day: "2-digit",
          year: "numeric",
        });
        const set = (id, value) => {
          const node = el(id);
          if (node) node.textContent = value;
        };
        set("summaryModule", moduleName);
        set("summaryPhase", phaseMap[phase] || phase);
        set("summaryItems", String(items));
        set("summaryClues", String(clues));
        set("summaryDate", date);
        set("summaryIntro", intro || "—");
      }

      function normalizeFinding(raw) {
        if (!raw) return null;
        if (typeof raw === "string") {
          return { description: raw, reveal: "", effect: "", name: "" };
        }
        if (typeof raw === "object") {
          const description =
            raw.description ||
            raw.name ||
            raw.clue_id ||
            raw.item_id ||
            raw.id ||
            "";
          const name = raw.name || raw.clue_id || raw.item_id || raw.id || "";
          const reveal = raw.reveal || raw.details || "";
          const effect = raw.effect || "";
          return { description, reveal, effect, name };
        }
        return null;
      }

      function extractFindings(params, type) {
        const list = [];
        if (!params || typeof params !== "object") return list;
        const plural = `${type}s`;
        if (Array.isArray(params[plural])) {
          params[plural].forEach((entry) => {
            const normalized = normalizeFinding(entry);
            if (normalized?.description) list.push(normalized);
          });
        }
        if (params[type]) {
          const normalized = normalizeFinding(params[type]);
          if (normalized?.description) list.push(normalized);
        }
        if (!list.length) {
          const normalized = normalizeFinding(params);
          if (normalized?.description) list.push(normalized);
        }
        return list;
      }

      function mergeFinding(list, next) {
        if (!next?.description) return false;
        const exists = list.some((item) => item.description === next.description);
        if (!exists) {
          list.push(next);
          return true;
        }
        return false;
      }

      function parseFindingFromStatus(statusText) {
        if (!statusText) return null;
        const text = String(statusText).trim();
        const itemPrefix = "持有道具：";
        const cluePrefix = "持有线索：";
        if (text.startsWith(itemPrefix)) {
          return { type: "item", value: text.slice(itemPrefix.length).trim() };
        }
        if (text.startsWith(cluePrefix)) {
          return { type: "clue", value: text.slice(cluePrefix.length).trim() };
        }
        return null;
      }

      function applyFindingAction(action) {
        const params = action?.parameters || {};
        const target = params.player_id || params.playerId || params.player || "";
        if (target && target !== playerId) return;
        if (action.function_name === "add_item") {
          extractFindings(params, "item").forEach((normalized) => {
            const added = mergeFinding(state.items, normalized);
            if (added) {
              state.findingHighlights.items[normalized.description] = Date.now();
            }
          });
          return;
        }
        if (action.function_name === "add_clue") {
          extractFindings(params, "clue").forEach((normalized) => {
            const added = mergeFinding(state.clues, normalized);
            if (added) {
              state.findingHighlights.clues[normalized.description] = Date.now();
            }
          });
          return;
        }
        if (action.function_name === "add_status") {
          const statusText = params.status || params.status_text || params.text || "";
          const parsed = parseFindingFromStatus(statusText);
          if (!parsed?.value) return;
          if (parsed.type === "item") {
            const added = mergeFinding(state.items, { description: parsed.value, reveal: "" });
            if (added) {
              state.findingHighlights.items[parsed.value] = Date.now();
            }
          } else if (parsed.type === "clue") {
            const added = mergeFinding(state.clues, { description: parsed.value, reveal: "" });
            if (added) {
              state.findingHighlights.clues[parsed.value] = Date.now();
            }
          }
        }
      }

      function syncFindingsFromState() {
        const player = state.stateView.players?.[playerId] || {};
        const shared = state.stateView.shared_findings || {};
        const items = [];
        const clues = [];
        const addFindings = (source, target) => {
          (source || []).map(normalizeFinding).filter(Boolean).forEach((entry) => {
            mergeFinding(target, entry);
          });
        };
        addFindings(shared.items, items);
        addFindings(shared.clues, clues);
        addFindings(player.items, items);
        addFindings(player.clues, clues);
        const statuses = (player.statuses || [])
          .map((status) => parseFindingFromStatus(status))
          .filter(Boolean);
        statuses.forEach((entry) => {
          if (entry.type === "item") {
            mergeFinding(items, { description: entry.value, reveal: "" });
          } else if (entry.type === "clue") {
            mergeFinding(clues, { description: entry.value, reveal: "" });
          }
        });
        state.items = items;
        state.clues = clues;
      }

      function rebuildFindingsFromHistory() {
        state.items = [];
        state.clues = [];
        state.history.forEach((entry) => {
          (entry.actions || []).forEach((action) => {
            if (["add_item", "add_clue", "add_status"].includes(action.function_name)) {
              applyFindingAction(action);
            }
          });
        });
      }

      function renderFindings() {
        const itemList = el("itemList");
        const clueList = el("clueList");
        if (!itemList || !clueList) return;
        const now = Date.now();
        if (!state.items.length) {
          itemList.innerHTML = "<div class=\"muted\">暂无物品</div>";
        } else {
          itemList.innerHTML = "";
          state.items.forEach((item) => {
            const desc = item.description || "—";
            const name = item.name || desc;
            const effect = item.effect || item.reveal || "";
            const revealText = `描述：${desc}\n效果：${effect || "无"}`;
            const line = document.createElement("div");
            const highlightAt = state.findingHighlights.items[desc] || 0;
            line.className = now - highlightAt < 2000 ? "info-item new" : "info-item";
            line.innerHTML = `
              <div class="info-text">${name}</div>
              <div class="info-reveal">${revealText.replace(/\n/g, "<br />")}</div>
            `;
            itemList.appendChild(line);
          });
        }
        if (!state.clues.length) {
          clueList.innerHTML = "<div class=\"muted\">暂无线索</div>";
        } else {
          clueList.innerHTML = "";
          state.clues.forEach((clue) => {
            const desc = clue.description || "—";
            const name = clue.name || desc;
            const reveal = clue.reveal || "";
            const revealText = `描述：${desc}\n揭示：${reveal || "无"}`;
            const line = document.createElement("div");
            const highlightAt = state.findingHighlights.clues[desc] || 0;
            line.className = now - highlightAt < 2000 ? "info-item new" : "info-item";
            line.innerHTML = `
              <div class="info-text">${name}</div>
              <div class="info-reveal">${revealText.replace(/\n/g, "<br />")}</div>
            `;
            clueList.appendChild(line);
          });
        }
      }

      function toastIcon(type) {
        if (type === "apply_damage") {
          return "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='1.5'><path d='M12 21s-7-4.35-7-10a4 4 0 0 1 7-2 4 4 0 0 1 7 2c0 5.65-7 10-7 10z'/></svg>";
        }
        if (type === "apply_sanity_change") {
          return "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='1.5'><path d='M9 4a7 7 0 0 1 9 9'/><path d='M15 20a7 7 0 0 1-9-9'/><path d='M8 12h8'/></svg>";
        }
        return "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='1.5'><path d='M12 3v18'/><path d='M5 12h14'/></svg>";
      }

      function showToast(text, type, durationMs = 3000) {
        const stack = el("toastStack");
        if (!stack) return;
        const item = document.createElement("div");
        item.className = "toast";
        item.innerHTML = `<div class="toast-icon">${toastIcon(type)}</div><div>${text}</div>`;
        stack.appendChild(item);
        setTimeout(() => {
          item.remove();
        }, durationMs);
      }

      function toastFromEntry(entry) {
        const keyParts = [];
        if (entry?.actions?.[0]) {
          const action = entry.actions[0];
          keyParts.push(action.function_name, JSON.stringify(action.parameters || {}));
        } else if (entry?.state_diff?.players) {
          const players = entry.state_diff.players;
          const playerId = Object.keys(players)[0] || "";
          const data = players[playerId] || {};
          if (data.last_damage) keyParts.push("apply_damage", playerId, data.last_damage.amount);
          if (data.last_sanity) keyParts.push("apply_sanity_change", playerId, data.last_sanity.amount);
        }
        const key = keyParts.join("|");
        if (!key) return;
        const now = Date.now();
        const last = state.toastCache.get(key) || 0;
        if (now - last < 4000) return;
        state.toastCache.set(key, now);
        const action = entry?.actions?.[0];
        if (action) {
          const fn = action.function_name;
          if (["apply_damage", "apply_sanity_change", "update_player_attribute", "add_status", "remove_status"].includes(fn)) {
            const amount = action.parameters?.amount;
            if (fn === "apply_damage") {
              showToast(`生命值 -${Math.abs(amount ?? 0)}`, fn);
              return;
            }
            if (fn === "apply_sanity_change") {
              const delta = Number(amount ?? 0);
              const label = delta < 0 ? `理智 ${delta}` : `理智 +${delta}`;
              showToast(label, fn);
              return;
            }
            if (fn === "update_player_attribute") {
              const attr = action.parameters?.attribute || "";
              const delta = Number(action.parameters?.delta ?? 0);
              const sign = delta >= 0 ? "+" : "";
              showToast(`${attr} ${sign}${delta}`, fn);
              return;
            }
            if (fn === "add_status") {
              const statusText = action.parameters?.status || action.parameters?.status_text || action.parameters?.text || "";
              const parsed = parseFindingFromStatus(statusText);
              if (parsed?.value) {
                const label = parsed.type === "item" ? `获得物品：${parsed.value}` : `获得线索：${parsed.value}`;
                showToast(label, "add_status", 3000);
                return;
              }
            }
            return;
          }
          if (fn === "add_item" || fn === "add_clue") {
            const raw = action.parameters?.item || action.parameters?.clue || action.parameters || {};
            const normalized = normalizeFinding(raw);
            if (normalized?.description) {
              const label = fn === "add_item" ? `获得物品：${normalized.description}` : `获得线索：${normalized.description}`;
              showToast(label, fn, 3000);
              return;
            }
          }
        }
        if (entry?.action_type === "state_update" && entry?.state_diff?.players) {
          const players = entry.state_diff.players;
          const playerId = Object.keys(players)[0];
          const data = players[playerId] || {};
          if (data.last_damage) {
            const amount = data.last_damage?.amount ?? 0;
            showToast(`生命值 -${Math.abs(amount)}`, "apply_damage");
          } else if (data.last_sanity) {
            const amount = data.last_sanity?.amount ?? 0;
            const delta = Number(amount);
            const label = delta < 0 ? `理智 ${delta}` : `理智 +${delta}`;
            showToast(label, "apply_sanity_change");
          }
        }
      }

      function appendStreamDelta(streamId, delta) {
        const container = el("history");
        const item = container.querySelector(`[data-stream-id="${streamId}"]`);
        if (!item) return false;
        const content = item.querySelector(".history-content");
        if (!content) return false;
        const shouldStick = container.scrollTop + container.clientHeight >= container.scrollHeight - 40;
        content.textContent = (content.textContent || "") + delta;
        if (shouldStick) {
          container.scrollTop = container.scrollHeight;
        }
        return true;
      }

      function showEndingModal(entry) {
        const modal = el("endingModal");
        const textEl = el("endingText");
        const description = entry?.state_diff?.description || "";
        const keeperText = entry?.state_diff?.keeper_text || "";
        const conditions = entry?.state_diff?.conditions || "";
        const combined = keeperText ? `${keeperText}\n\n${description}` : description;
        const withConditions = conditions ? `${combined}\n\n触发条件：${conditions}` : combined;
        textEl.textContent = withConditions || "模组已结束。";
        modal.classList.remove("hidden");
      }

      function renderPlayerCard() {
        const player = state.stateView.players?.[playerId] || {};
        el("cardName").textContent = player.name || "Unknown";
        const profKey = player.profession || "";
        const profLabel = state.professions[profKey]?.label_zh || state.professions[profKey]?.label || profKey;
        el("cardProfession").textContent = profLabel;
        const bg = player.background || state.professions[profKey]?.background_zh || "";
        const bgEl = el("cardBackground");
        if (bgEl) bgEl.textContent = bg;
        const chip = el("cardChip");
        chip.textContent = player.gender || "";
        chip.style.background = player.color || "#475569";
        const stats = player.stats || {};
        const hpMax = stats.hp_max ?? stats.hp ?? 0;
        const sanMax = stats.san_max ?? stats.san ?? 0;
        const hp = Math.min(stats.hp ?? 0, hpMax);
        const san = Math.min(stats.san ?? 0, sanMax);
        const hpRatio = hpMax ? Math.max(0, Math.min(1, hp / hpMax)) : 0;
        const sanRatio = sanMax ? Math.max(0, Math.min(1, san / sanMax)) : 0;
        el("cardStats").innerHTML = `
          <div>
            <div class="stat-badge">生命 ${hp} / ${hpMax}</div>
            <div class="stat-bar"><span style="width:${Math.round(hpRatio * 100)}%"></span></div>
          </div>
          <div>
            <div class="stat-badge">理智 ${san} / ${sanMax}</div>
            <div class="stat-bar"><span style="width:${Math.round(sanRatio * 100)}%"></span></div>
          </div>
          <div>魔力: ${stats.mp ?? 0}</div>
          <div>幸运: ${stats.luck ?? 0}</div>
        `;
        const attrs = player.attributes || {};
        const attrLabels = {
          str: "力量",
          dex: "敏捷",
          int: "智力",
          con: "体质",
          app: "外貌",
          pow: "意志",
          siz: "体型",
          edu: "教育",
        };
        const attrEl = el("cardAttributes");
        if (attrEl) {
          attrEl.className = state.attrsCollapsed ? "attributes attrs-collapsed" : "attributes";
        }
        const toggleBtn = el("toggleAttrs");
        if (toggleBtn) {
          toggleBtn.textContent = state.attrsCollapsed ? "展开属性" : "收起属性";
        }
        el("cardAttributes").innerHTML = Object.entries(attrs)
          .map(([key, value]) => `<div>${attrLabels[key] || key}: ${value}</div>`)
          .join("");
      }

      function renderRoomPlayers() {
        const container = el("roomPlayers");
        container.innerHTML = "";
        Object.values(state.stateView.players || {})
          .filter((p) => state.onlineIds.includes(p.player_id))
          .forEach((p) => {
          const item = document.createElement("div");
          item.className = "player";
          const hpMax = p.stats?.hp_max ?? p.stats?.hp ?? 0;
          const sanMax = p.stats?.san_max ?? p.stats?.san ?? 0;
          const hp = Math.min(p.stats?.hp ?? 0, hpMax);
          const san = Math.min(p.stats?.san ?? 0, sanMax);
          const flag =
            hp <= 0
              ? "<span class=\"flag\">死亡</span>"
              : san <= 0
              ? "<span class=\"flag\">疯狂</span>"
              : "";
          item.innerHTML = `
            <span class="dot" style="background:${p.color || "#475569"}"></span>
            <span>${p.name || ""}</span>
            <span class="muted">生命 ${hp} / ${hpMax} | 理智 ${san} / ${sanMax}</span>
            ${flag}
          `;
          container.appendChild(item);
        });
      }

      function renderAll() {
        renderHistory();
        renderPlayerCard();
        renderRoomPlayers();
        updateActionLock();
        renderRollPanel();
        renderFindings();
        renderSummary();
      }

      function isActionEntry(entry) {
        return entry?.action_type === "dice_roll" || entry?.action_type === "state_update";
      }

      function pushHistoryEntry(entry, streamId) {
        if (streamId) {
          const idx = state.history.findIndex((e) => e.stream_id === streamId);
          if (idx >= 0) {
            state.history[idx] = { ...entry, stream_id: streamId };
          } else {
            state.history.push({ ...entry, stream_id: streamId });
          }
          return;
        }
        state.history.push(entry);
      }

      function flushPendingEntries() {
        if (!state.pendingEntries.length) return;
        const pending = state.pendingEntries;
        state.pendingEntries = [];
        pending.forEach(({ entry, streamId }) => {
          pushHistoryEntry(entry, streamId);
          toastFromEntry(entry);
        });
        renderHistory();
        renderRollPanel();
        renderFindings();
        renderSummary();
      }

      function renderRollPanel() {
        const panel = el("rollPanel");
        const last = [...state.history].reverse().find((e) => e.action_type === "dice_roll");
        if (!last || !last.state_diff) {
          panel.innerHTML = "<div class=\"muted\">暂无判定</div>";
          return;
        }
        const dice = last.state_diff.dice || {};
        if (last.state_diff.opposed) {
          const attacker = last.state_diff.attacker || {};
          const defender = last.state_diff.defender || {};
          const outcomeMap = {
            critical: "大成功",
            extreme_success: "极难成功",
            hard_success: "困难成功",
            regular_success: "成功",
            failure: "失败",
            fumble: "大失败",
          };
          const winner = last.state_diff.winner || "tie";
          panel.innerHTML = `
            <strong>对抗检定</strong>
            <div>攻击方：${attacker.skill_name || "攻击方"} / ${attacker.total ?? "?"} / ${outcomeMap[attacker.success_level] || attacker.success_level}</div>
            <div>防守方：${defender.skill_name || "防守方"} / ${defender.total ?? "?"} / ${outcomeMap[defender.success_level] || defender.success_level}</div>
            <div>胜者：${winner}</div>
          `;
          return;
        }
        const reason = last.state_diff.reason || "";
        const total = dice.total ?? 0;
          if (dice.type === "coc7e") {
            const target = dice.target ?? "?";
            const level = dice.success_level || "failure";
            const difficulty = dice.difficulty || "regular";
            const difficultyMap = { regular: "常规", hard: "困难", extreme: "极难" };
            const outcomeMap = {
              critical: "大成功",
              extreme_success: "极难成功",
              hard_success: "困难成功",
              regular_success: "成功",
              failure: "失败",
              fumble: "大失败",
            };
            const badgeClass = level === "failure" || level === "fumble" ? "fail" : "success";
            panel.innerHTML = `
              <strong>检定</strong>
              <div>目标值：${target} / 难度：${difficultyMap[difficulty] || difficulty}</div>
              <div>结果：${total} <span class="badge ${badgeClass}">${outcomeMap[level] || level}</span></div>
              <div>原因：${reason}</div>
            `;
            return;
        }
        const outcome = total <= 5 ? "极难成功" : total <= 50 ? "成功" : "失败";
        const badgeClass = total <= 50 ? "success" : "fail";
        panel.innerHTML = `
          <strong>掷骰</strong>
          <div>表达式：${dice.expression || ""}</div>
          <div>结果：${total} <span class="badge ${badgeClass}">${outcome}</span></div>
          <div>原因：${reason}</div>
        `;
      }

      function updateActionLock() {
        const player = state.stateView.players?.[playerId] || {};
        const stats = player.stats || {};
        const phase = state.stateView.phase || "lobby";
        const locked = phase !== "active" || (stats.hp ?? 1) <= 0 || (stats.san ?? 1) <= 0;
        const input = el("actionInput");
        const btn = el("send");
        const notice = el("inputNotice");
        input.disabled = locked;
        btn.disabled = locked;
        if (locked) {
          if (phase !== "active") {
            input.placeholder = "等待调查开始";
            setInputNotice("调查尚未开始，请等待主持人开启模组。");
          } else {
            if ((stats.hp ?? 1) <= 0) {
              input.placeholder = "你已死亡";
              setInputNotice("你的角色已死亡，无法行动。");
            } else if ((stats.san ?? 1) <= 0) {
              input.placeholder = "你已陷入疯狂";
              setInputNotice("你的角色已陷入疯狂，无法行动。");
            } else {
              input.placeholder = "行动输入...";
              setInputNotice("");
            }
            setNotice("你的角色已死亡或疯狂，无法行动。");
          }
        } else {
          input.placeholder = "行动输入...";
          setInputNotice("");
          setNotice("");
        }
      }

      function setInputNotice(text) {
        const notice = el("inputNotice");
        if (!notice) return;
        notice.textContent = text;
        notice.classList.toggle("active", Boolean(text));
      }

      function renderLobbyPlayers() {
        const select = el("existingPlayers");
        const list = state.players;
        if (!list.length) {
          select.innerHTML = "<option value=\"\">暂无角色</option>";
          return;
        }
        select.innerHTML = list
          .map((p) => {
            const profLabel =
              state.professions[p.profession]?.label_zh ||
              state.professions[p.profession]?.label ||
              p.profession ||
              "";
            const label = `${p.name || "未知"} / ${p.gender || "未知"} / ${profLabel}`;
            return `<option value=\"${p.player_id}\">${label}</option>`;
          })
          .join("");
      }

      async function loadProfessions() {
        const serverUrl = window.location.origin;
        try {
          const res = await fetch(`${serverUrl}/professions`);
          const data = await res.json();
          state.professions = data.professions || {};
        } catch (e) {
          state.professions = {};
        }
        const select = el("profession");
        const keys = Object.keys(state.professions);
        const fallbackLabels = {
          retired_soldier: "退役士兵",
          police: "警察",
          doctor: "医生",
          professor: "大学教授",
          private_detective: "私人侦探",
          journalist: "记者",
          occult_researcher: "神秘学研究者",
          engineer: "工程师",
          archaeologist: "考古学家",
          nurse: "护士",
          librarian: "图书馆员",
          antiquarian: "古董商",
          author: "作家",
          painter: "画家",
          sculptor: "雕塑家",
          dockworker: "码头工人",
          chemist: "化学师",
        };
        const list = keys.length ? keys : [
          "retired_soldier",
          "police",
          "doctor",
          "professor",
          "private_detective",
          "journalist",
          "occult_researcher",
          "engineer",
          "archaeologist",
          "nurse",
          "librarian",
          "antiquarian",
          "author",
          "painter",
          "sculptor",
          "dockworker",
          "chemist",
        ];
        select.innerHTML = list
          .map((p) => {
            const label =
              state.professions[p]?.label_zh ||
              state.professions[p]?.label ||
              fallbackLabels[p] ||
              p;
            return `<option value="${p}">${label}</option>`;
          })
          .join("");
      }

      async function loadPlayers() {
        const serverUrl = window.location.origin;
        try {
          const res = await fetch(
            `${serverUrl}/players?machine_id=${state.machineId}&include_unbound=true`
          );
          const data = await res.json();
          state.players = data.players || [];
        } catch (e) {
          state.players = [];
        }
        renderLobbyPlayers();
      }

      function setNotice(text) {
        el("notice").textContent = text;
      }

      el("create").addEventListener("click", async () => {
        const serverUrl = window.location.origin;
        const profession = el("profession").value;
        const skills = state.professions[profession]?.skills || {};
        const attributes = {
          str: 50, dex: 50, int: 50, con: 50, app: 50, pow: 50, siz: 50, edu: 50,
          ...(state.professions[profession]?.attributes || {}),
        };
        const stats = {
          hp: 10, hp_max: 10, san: 60, san_max: 60, mp: 10, luck: 50,
          ...(state.professions[profession]?.stats || {}),
        };
        if (stats.hp_max == null) stats.hp_max = stats.hp;
        if (stats.san_max == null) stats.san_max = stats.san;
        playerId = makeUUID();
        const payload = {
          player_id: playerId,
          name: el("name").value,
          gender: el("gender").value,
          color: el("color").value,
          profession,
          machine_id: state.machineId,
          background: state.professions[profession]?.background_zh || "",
          attributes,
          stats,
          skills,
          statuses: [],
        };
        try {
          const res = await fetch(`${serverUrl}/players`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          setNotice("角色创建成功。");
          await loadPlayers();
          el("existingPlayers").value = playerId;
          el("lobby").classList.add("hidden");
          el("game").classList.remove("hidden");
          el("backToLobby").classList.remove("hidden");
          connect();
        } catch (e) {
          setNotice("角色创建失败，请检查后端服务。");
        }
      });

      el("useExisting").addEventListener("click", () => {
        const selected = el("existingPlayers").value;
        if (!selected) {
          setNotice("请选择一个角色。");
          return;
        }
        playerId = selected;
        fetch(`${window.location.origin}/players/claim`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ player_id: playerId, machine_id: state.machineId }),
        });
        el("lobby").classList.add("hidden");
        el("game").classList.remove("hidden");
        el("backToLobby").classList.remove("hidden");
        connect();
      });

      el("deletePlayer").addEventListener("click", async () => {
        const selected = el("existingPlayers").value;
        if (!selected) {
          setNotice("请选择一个角色。");
          return;
        }
        const res = await fetch(`${window.location.origin}/players/delete`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ player_id: selected }),
        });
        const data = await res.json();
        if (data.ok) {
          setNotice("角色已删除。");
          await loadPlayers();
        } else {
          setNotice(data.error || "删除失败。");
        }
      });

      function connect() {
        if (state.ws) state.ws.close();
        el("status").className = "status warn";
        el("status").textContent = "CONNECTING";
        state.ws = new WebSocket(wsUrl);
        state.ws.onopen = () => {
          el("status").className = "status on";
          el("status").textContent = "CONNECTED";
          state.ws.send(JSON.stringify({
            type: "client.join",
            payload: { player_id: playerId, role: "player" }
          }));
        };
        state.ws.onmessage = (evt) => {
          const message = JSON.parse(evt.data);
          if (message.type === "server.session_state") {
            state.sessionInfo = message.payload;
            state.history = message.payload.latest_history || [];
            state.stateView = message.payload.visible_state || { players: {} };
            state.onlineIds = message.payload.online_player_ids || [];
            if (message.payload.theme) {
              document.documentElement.setAttribute("data-theme", message.payload.theme);
            }
            const phase = state.stateView.phase || "lobby";
            if (phase !== "active") {
              state.items = [];
              state.clues = [];
              state.findingHighlights = { items: {}, clues: {} };
            }
            rebuildFindingsFromHistory();
            syncFindingsFromState();
            renderAll();
            return;
          }
          if (message.type === "server.history_append") {
            const entry = message.payload.entry;
            const streamId = message.payload.stream_id;
            if (Array.isArray(entry)) {
              state.history = entry;
              rebuildFindingsFromHistory();
            } else {
              if (state.streamingCount > 0 && (!streamId || !state.activeStreamIds.has(streamId))) {
                state.pendingEntries.push({ entry, streamId });
              } else {
                pushHistoryEntry(entry, streamId);
                toastFromEntry(entry);
                (entry.actions || []).forEach((action) => {
                  if (["add_item", "add_clue", "add_status"].includes(action.function_name)) {
                    applyFindingAction(action);
                  }
                });
              }
            }
            renderHistory();
            renderRollPanel();
            renderFindings();
            if (entry?.state_diff?.ending_id) {
              showEndingModal(entry);
            }
            return;
          }
          if (message.type === "server.keeper_stream_start") {
            const { stream_id, message_type } = message.payload;
            state.streamingCount += 1;
            state.activeStreamIds.add(stream_id);
            const exists = state.history.findIndex((e) => e.stream_id === stream_id) >= 0;
            if (!exists) {
              state.history.push({
                stream_id,
                actor_type: "keeper",
                message_type,
                content: { zh: "" },
              });
              renderHistory();
            }
            return;
          }
          if (message.type === "server.keeper_stream_delta") {
            const { stream_id, delta } = message.payload;
            const idx = state.history.findIndex((e) => e.stream_id === stream_id);
            if (idx >= 0) {
              const current = state.history[idx].content?.zh || "";
              state.history[idx].content = { zh: current + delta };
              if (!appendStreamDelta(stream_id, delta)) {
                renderHistory();
              }
            }
            return;
          }
          if (message.type === "server.state_update") {
            state.stateView = message.payload.state_diff || { players: {} };
            state.onlineIds = message.payload.online_player_ids || state.onlineIds;
            const phase = state.stateView.phase || "lobby";
            if (phase !== "active") {
              state.items = [];
              state.clues = [];
              state.findingHighlights = { items: {}, clues: {} };
            }
            syncFindingsFromState();
            renderPlayerCard();
            renderRoomPlayers();
            updateActionLock();
            renderFindings();
            renderSummary();
          }
          if (message.type === "server.module_info") {
            return;
          }
          if (message.type === "server.theme_update") {
            const theme = message.payload?.theme || "archive";
            document.documentElement.setAttribute("data-theme", theme);
            return;
          }
          if (message.type === "server.history_clear") {
            state.history = [];
            state.streamingCount = 0;
            state.pendingEntries = [];
            state.activeStreamIds.clear();
            state.items = [];
            state.clues = [];
            state.findingHighlights = { items: {}, clues: {} };
            renderHistory();
            renderRollPanel();
            renderFindings();
            return;
          }
          if (message.type === "server.keeper_stream_end") {
            renderHistory();
            state.streamingCount = Math.max(0, state.streamingCount - 1);
            state.activeStreamIds.delete(message.payload?.stream_id);
            if (state.streamingCount === 0) {
              flushPendingEntries();
            }
          }
        };
        state.ws.onclose = () => {
          el("status").className = "status off";
          el("status").textContent = "DISCONNECTED";
        };
        state.ws.onerror = () => {
          el("status").className = "status warn";
          el("status").textContent = "ERROR";
          setNotice("连接失败，请检查后端服务与 WS 地址。");
        };
      }

      el("send").addEventListener("click", () => {
        if (!state.ws || state.ws.readyState !== 1) return;
        const input = el("actionInput");
        const player = state.stateView.players?.[playerId] || {};
        const stats = player.stats || {};
        if ((stats.hp ?? 1) <= 0 || (stats.san ?? 1) <= 0) {
          setNotice("你的角色已死亡或疯狂，无法行动。");
          return;
        }
        if (!input.value.trim()) return;
        state.ws.send(JSON.stringify({
          type: "client.player_action",
          payload: {
            player_id: playerId,
            action_text: { zh: input.value, en: "" }
          }
        }));
        input.value = "";
      });

      el("closeEnding").addEventListener("click", () => {
        el("endingModal").classList.add("hidden");
      });

      el("actionInput").addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.isComposing && e.keyCode !== 229) {
          el("send").click();
        }
      });

      el("toggleAttrs").addEventListener("click", () => {
        state.attrsCollapsed = !state.attrsCollapsed;
        renderPlayerCard();
      });

      el("backToLobby").addEventListener("click", async () => {
        if (state.ws) state.ws.close();
        state.history = [];
        state.streamingCount = 0;
        state.pendingEntries = [];
        state.activeStreamIds.clear();
        state.items = [];
        state.clues = [];
        state.findingHighlights = { items: {}, clues: {} };
        document.documentElement.setAttribute("data-theme", "archive");
        el("game").classList.add("hidden");
        el("lobby").classList.remove("hidden");
        el("backToLobby").classList.add("hidden");
        await loadPlayers();
        renderLobbyPlayers();
        renderFindings();
      });

      loadProfessions();
      loadPlayers();
    </script>
  </body>
</html>
